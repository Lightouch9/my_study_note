# 整体工作流程

- 初始化`WebServer`对象`server`
- 启动`server`的日志记录
- 启动`server`的数据库
- 启动`server`的线程池
- 设置`server`的触发模式
- 初始化`server`的事件监听设置
- 启动`server`的核心事件循环

# `WebServer::eventListen()`

调用该方法设置服务器监听

## 工作流程

- 创建监听套接字`m_listenfd`
- 设置优雅关闭连接，决定关闭时是否强制等待发送完成
- 初始化服务器的地址结构`sockaddr_in`
- 设置地址重用
- 绑定和监听
- 初始化定时器
- 创建epoll事件表
- 添加监听套接字到事件表
- 创建信号处理的管道
- 设置信号处理行为
- 设置定时器
- 将管道和epollfd记录进工具类

# WebServer::eventLoop()

主事件循环处理所有事件和连接

## 工作流程

- 设置超时标志`timeout` 与停止状态标志`stop_server`
- 主循环，持续监听事件`epoll_wait`，循环停止条件`stop_server`为真
- 根据`epoll_wait`返回的就绪事件的数量处理就绪事件集合`events`中的事件
- 超时处理，如果`timeout`为真，调用对应处理函数

# WebServer::dealclientdata()

处理新的客户端连接

## 工作流程

- 定义存储客户端地址信息的变量
- 触发模式处理
  - LT
    - 接受连接
    - 检查当前活动的用户数量是否超出限制
    - 为新连接初始化定时器
  - ET
    - 通过`while`循环连续处理，循环内容同`LT`模式的三步，接受所有连接直到没有可用连接

# WebServer::dealwithread()

该方法负责处理从客户端读取数据

## 工作流程

- 获取定时器以用于后续更新或处理
- Reactor模式
  - 调整定时器，更新过期时间
  - 将读事件放入请求队列
  - 检查是否有需要处理的标志，更新定时器，设置`improv`
- Proactor模式
  - 尝试读取，成功将读事件放入请求队列，更新定时器
  - 失败，处理定时器超时，关闭连接

# WebServer::deal_timer()

处理与客户端连接相关的定时器，接收参数，`timer`当前连接的定时器，`sockfd`当前客户端的文件描述符

- 调用传入定时器的回调函数
- 删除定时器
- 记录日志

# threadpool<T>::run()

该函数是线程池中各线程运行的函数

## 工作流程

- 获取信号量`m_queuestat`
- 获取任务队列的互斥锁`m_queuelocker`
- 检查队列是否为空
- 取出队列中第一个请求，将其从任务队列中移除，并释放互斥锁
- 根据事件处理模式的设定处理请求
  - reactor模式
  - proactor模式

# http_conn::process()

该函数描述了一个http连接的完整工作周期

## 工作周期

- 调用`process_read()`读取并解析http请求，获得状态码
- 如果请求未完全读取则继续监听读事件
- 调用`process_write`对本次请求生成http响应，如果响应生成失败，关闭连接
- 监听写事件，表示服务器准备好向客户端发送数据

# http_conn::process_read()

该函数用于读取并解析客户端的http请求，返回状态码

# http_conn::do_request()

该函数用于处理http请求报文的请求，并返回响应的内容。根据请求的路径返回相应的文件路径。

`http_conn::do_request()` 函数的作用是处理 HTTP 请求并决定将要返回的响应内容，包括处理一些 CGI 请求（如登录和注册）。具体来说，这个函数根据请求的路径生成相应的文件路径，将请求映射到文件，并为后续的响应处理做准备。

### 函数解析

1. **设置文件路径**
   - 使用 `strcpy(m_real_file, doc_root)` 将服务器的文档根目录赋值给 `m_real_file`。
   - `doc_root` 是服务器文档的根目录，`m_real_file` 保存要访问的文件的完整路径。
   - `const char *p = strrchr(m_url, '/')` 找到请求 URL 中最后一个 `'/'`，用于确定请求的类型。

2. **处理 CGI 请求**
   - 当 `cgi == 1` 且 `*(p + 1) == '2'` 或 `*(p + 1) == '3'` 时，进入 CGI 处理流程。
   - `cgi == 1` 表示需要进行 CGI 处理，如登录（`2`）或注册（`3`）。

   **提取用户名和密码**
   - 用户名和密码以 `user=123&passwd=123` 这种形式保存在 `m_string` 中。
   - 通过遍历 `m_string` 来提取用户名和密码。

   **注册处理**
   - 当 `*(p + 1) == '3'` 时，表示这是注册请求。
   - 构建 SQL 插入语句，将用户名和密码添加到数据库中。
   - 使用 `users` 哈希表检查是否有重名用户：
     - 如果没有重名，则插入数据库并将用户添加到 `users` 中。
     - 若成功，则将 `m_url` 设置为登录页面 (`/log.html`)；否则设置为注册错误页面 (`/registerError.html`)。

   **登录处理**
   - 当 `*(p + 1) == '2'` 时，表示这是登录请求。
   - 通过 `users` 哈希表检查用户名和密码是否匹配：
     - 若匹配，则将 `m_url` 设置为欢迎页面 (`/welcome.html`)。
     - 否则设置为登录错误页面 (`/logError.html`)。

3. **处理其他 URL 请求**
   - 根据 `*(p + 1)` 的值，确定要返回的页面：
     - `'0'`：注册页面 (`/register.html`)
     - `'1'`：登录页面 (`/log.html`)
     - `'5'`：图片页面 (`/picture.html`)
     - `'6'`：视频页面 (`/video.html`)
     - `'7'`：粉丝页面 (`/fans.html`)
   - 如果没有匹配的值，则将 `m_url` 拼接到 `m_real_file` 后面。

4. **检查文件的有效性**
   
   - 使用 `stat(m_real_file, &m_file_stat)` 检查文件的状态：
     - 如果文件不存在，返回 `NO_RESOURCE`。
     - 如果文件不可读（没有其他用户的读取权限），返回 `FORBIDDEN_REQUEST`。
     - 如果请求的路径是一个目录，返回 `BAD_REQUEST`。
   
5. **映射文件到内存**
   - 使用 `open(m_real_file, O_RDONLY)` 打开文件。
   - 使用 `mmap` 将文件映射到内存，`m_file_address` 保存映射的内存地址。
   - 关闭文件描述符 `fd`。
   - 返回 `FILE_REQUEST` 表示文件请求成功，可以进行后续的响应发送。

### 关键点解析

- **CGI 处理**：
  - 登录和注册请求通过提取表单数据进行处理，使用 SQL 语句操作数据库。
  - 通过 `users` 哈希表来存储和验证用户信息。

- **文件映射**：
  - 使用 `mmap` 将文件映射到内存，这样可以直接通过内存地址访问文件内容，提高效率。

- **安全性**：
  - 检查文件的权限和类型，防止对不可访问或无效的文件进行处理。

### 总结

`do_request()` 函数根据请求的 URL 生成相应的文件路径，并处理登录、注册等请求，最终将请求的文件映射到内存中，准备后续的响应发送。

# 其他

- 许多类的成员变量使用`m`作为前缀，用于区分成员变量和局部变量，这里的`m`可以理解为`member`，是一种常见的编码规范或者风格
- 在服务器端设置监听套接字的地址结构时`address.sin_addr.s_addr=htonl(INADDR_ANY);`，其中`INADDR_ANY`意味着`0.0.0.0`地址，即该监听套接字绑定到本地任意一个ip地址，在这里意味着服务器接受发送到主机任意ip地址的连接，而不是某个特定的ip地址。因为服务器可能分配有多个ip地址，或是动态获取的ip地址，这样设置不需要指定一个确定的ip地址，简化配置。