# 互斥锁
通过创建互斥锁锁定代码块，所有线程当需要执行被加锁的代码块时，只有一个线程能够成功加锁，获得执行加锁区的代码的权利，其余的线程则需要等待锁的释放，通过互斥锁实现多个线程对临界资源的访问。
Linux中互斥锁的数据类型为`pthread_mutex_t`
```c
pthread_mutex_t mutex;
```
5个互斥锁基本操作函数，调用成功时返回值为0，失败则会返回错误码。：
```c
//互斥锁初始化
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
				const pthread_mutexattr_t *restrict attr);
//摧毁/释放互斥锁资源
int pthread_mutex_destroy(pthread_mutex_t *mutex);
```
>`pthread_mutex_destory()`是用来摧毁一个互斥锁(mutex)的，也就是释放资源，避免内存泄漏等问题，而且一个互斥锁被摧毁时必须确保没有线程在使用它，处于解锁状态。
`restrict`关键字修饰的指针拥有对其指向的内存地址唯一的访问权限，其他指向此内存地址的指针无法访问该内存地址。

上面两个函数中参数解释：
mutex:互斥锁变量的地址
attr:用于指定互斥锁的属性，一般指定为NULL，使用默认属性。
```c
//互斥锁上锁
int pthread_mutex_lock(pthread_mutex_t *mutex);
```
当调用这个函数时，会首先判断传入的互斥锁是否处于被锁定的状态，
如果已经被锁定了，那就会加锁失败，此线程会在此阻塞。
如果没有被锁定，则加锁成功。
```c
//尝试加锁
int pthread_mutex_trylock(pthread_mutex_t *mutex);
```
尝试加锁`try_lock`与加锁`lock`不同在于如果`try_lock`加锁失败并不会在此阻塞，而是返回错误号。
```c
//互斥锁解锁
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```
解除对于互斥锁的锁定，前提是此线程对此互斥锁加锁。
# 死锁问题
当存在两个线程，每个线程都需要同时拥有资源A与资源B才能正常工作，而当一个线程只持有一个资源时，它会无限等待直到另一个资源被释放然后去获取那个资源。  
这时就会容易出现死锁现象，如果线程1获取了资源A而线程2获取了资源B，这时两个线程都因为资源不全而无限等待另一个资源的释放，持有着资源却什么也不做，这也会影响其他需要这些资源的线程。  
这就是死锁
# 关于避免死锁的建议
在多线程编程中，死锁问题经常是不可预见、难以稳定复现的，所以在编程时要多加注意。
1. 规定锁的获取顺序，防止无限等待锁的释放；
2. 避免嵌套锁，尽量在持有锁时不要再去获取锁；
3. 设置等待超时，当在等待锁时设置超时，不要无限等待；
4. 限制锁的保护范围，只保护需要保护的数据，比如通过`{}`进行范围限定；
5. 避免在持有锁时调用外部代码，因为外部代码可能或作出线程危险的操作。

