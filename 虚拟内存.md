# 虚拟内存
## 为什么要有虚拟内存
> 解决多个程序同时运行在内存中产生冲突的问题，如果一个程序在内存中的某个位置写入了一个数据，但另一个程序在此位置又写入了它的数据，这样的话两个程序产生了冲突。
> 此问题的关键是两个程序都使用了绝对的物理地址，所以要对进程之间进行地址隔离。操作系统会对每个进程分配一套独立的`虚拟地址`，这样进程之间只会操作自己的`虚拟地址`，互不干涉。
## 两种地址
> 要实现虚拟内存这种机制，首先要建立`虚拟内存地址(virtual memory address)`与`物理内存地址(physical memory address)`之间的转换。
```
虚拟内存地址(virtual memory address):程序所使用的内存地址
物理内存地址(physical memory address):硬件内部实际的空间地址
```
> 简单的描述是进程的虚拟地址会经由CPU内的内存管理单元(MMU)进行关系映射，将其转换为物理地址，然后再通过此物理地址访问内存。
## 虚拟地址与物理地址管理
> 操作系统对于虚拟地址与物理地址之间关系的管理主要有两种方式：内存分段与内存分页。
### 内存分段
> 程序在内存中是由若干不同的分段组成的，如代码段、数据分段、栈段、堆段等，分段是将程序的内存空间分隔成不同段以进行隔离，并将分好的各段的基地址、段的界限、特权等级等信息保存在段表中。
#### 分段的地址结构
> 分段的逻辑地址由高位的`段选择符`(segment selector)和低位的`段内偏移量`(offset)组成
```
段选择符：段选择符保存在段寄存器中，段选择符最重要的数据是段号，用于在段表中查找用的索引。
段内偏移量：偏移量应该位于0和段界限之间，如果该偏移量是合法的，通过段选择符在段表中查找到段的基地址后，将基地址与偏移量相加即可得到物理内存的地址。
```
#### 分段结构的问题
##### 内存碎片
> 分段结构使得物理内存被程序按需划分为一段一段的，当程序执行结束，内存释放时，物理内存中的空闲也将是大小不同的零碎的段落，这使得即使物理内存中空闲的空间在大小上足够分配给下一个程序，但空闲空间是零碎的，导致无法装载该程序，即产生`外部内存碎片`。
##### 解决方案
> 外部内存碎片问题可以通过`内存交换`解决
> `内存交换`就是将物理内存中的程序写到硬盘中，然后再重新将其读取到内存中，重新读取会使该程序排在已使用的内存空间之后，从而使空闲碎片重新聚合，减少碎片。
```
这个内存交换在Linux就是swap分区，swap分区就是单独从硬盘中划分出来的区域用于内存与硬盘的交换。
```
##### 新的问题——内存交换效率低
> 在多线程系统中，使用分段内存的结构，容易产生外部内存碎片，而为了解决这个问题就要`内存交换`，但是内存与硬盘的读写速度差距太大，使得硬盘的读写速度成为瓶颈。
> 所以当进行频繁大量的`内存交换`就会效率低下。

### 内存分页
#### 多级页表
#### TLB
### 段页式内存管理